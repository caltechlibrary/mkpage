<!DOCTYPE html>
<html>
<head>
    <title>Caltech Library's Digital Library Development Sandbox</title>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/site.css">
</head>
<body>
<header>
<a href="http://library.caltech.edu"><img src="assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="index.html">README</a></li>
<li><a href="license.html">LICENSE</a></li>
<li><a href="install.html">INSTALL</a></li>
<li><a href="mkpage.html">mkpage</a></li>
<li><a href="mkslides.html">mkslides</a></li>
<li><a href="reldocpath.html">reldocpath</a></li>
<li><a href="sitemapper.html">sitemapper</a></li>
<li><a href="slugify.html">slugify</a></li>
<li><a href="ws.html">ws</a></li>
<li><a href="go-template-recipes.html">Go template recipes</a></li>
<li><a href="https://github.com/caltechlibrary/mkpage">Github</a></li>
</ul>

</nav>

<section>
<h1>mkpage</h1>

<p><em>mkpage</em> (pronounced &ldquo;make page&rdquo;) project is an experiment in decomposing a web content manage
systems functionality into a series of simple command line tools &ndash; <a href="mkpage.html">mkpage</a>,
<a href="mkslide.html">mkslide</a>, <a href="reldocpath.html">reldocpath</a>, <a href="slugify.html">slugify</a>,
<a href="sitemapper.html">sitemapper</a>, and <a href="ws.html">ws</a>. This makes creating static websites simple.<br />
Complex sites can be created with a little bit of Bash scripting.</p>

<p>This project started with the <em>mkpage</em> command.</p>

<h2>mkpage command</h2>

<p>The <em>mkpage</em> command is an experimental template engine with an embedded markdown processor. <em>mkpage</em> is
a simple command line tool which accepts key value pairs and applies them to a
Golang <a href="https://golang.org/pkg/text/template/">text/template</a>.  The key side of a pair corresponds to the
template element names that will be replaced in the render version of the document. If a key was cllaed
&ldquo;pageContent&rdquo; the template element would look like <code>{{ .pageContent }}</code>. The value of &ldquo;pageContent&rdquo; would
replace <code>{{ .pageContent }}</code>. Go text/templates elements can do more than that but the is the core idea.
On the value side of the key/value pair you have strings of one of three formats - plain text, markdown
and JSON.  These three formatted strings can be explicit strings, data from a file or content received from
a URL. Here&rsquo;s a basic demonstration starting with the template.</p>

<pre><code class="language-template">    Date: {{.now}}

    Hello {{.name -}},
    
    Forecast:

    {{range .weather.data.text}}
       + {{ . }}
    {{end}}

    Thank you

    {{.signature}}
</code></pre>

<p>To render the template above (i.e. myformletter.tmpl) is expecting values from various data sources.
This break down is as follows.</p>

<ul>
<li>&ldquo;now&rdquo; and &ldquo;name&rdquo; are explicit strings</li>
<li>&ldquo;weather&rdquo; comes from a URL of JSON content</li>
<li>&ldquo;signature&rdquo; comes from a file in our local disc</li>
</ul>

<p>Here is how we would express the key/value pairs on the command line.</p>

<pre><code class="language-shell">    mkpage &quot;now=text:$(date)&quot; \
        &quot;name=text:Little Frieda&quot; \
        &quot;weather=http://forecast.weather.gov/MapClick.php?lat=13.47190933300044&amp;lon=144.74977715100056&amp;FcstType=json&quot; \
        signature=testdata/signature.txt \
        testdata/myformletter.tmpl
</code></pre>

<p>Notice the two explicit strings are prefixed with &ldquo;text:&rdquo; (other possible formats are &ldquo;markdown:&ldquo;, &ldquo;json:&ldquo;).
Values without a prefix are assumed to be file paths. We see that in testdata/signature.txt.  Likewise the
weather data is coming from a URL. <em>mkpage</em> distinguishes that by the prefixes &ldquo;http://&rdquo; and &ldquo;https://&ldquo;.
Since a HTTP response contains headers describing the content type (e.g.  &ldquo;Content-Type: text/markdown&rdquo;) we
do not require any other prefix. Likewise a filename&rsquo;s extension can give us an inference of the data format
it contains. &ldquo;.json&rdquo; is a JSON document, &ldquo;.md&rdquo; is a Markdown document and everything else is just plain text.</p>

<p>Since we are leveraging Go&rsquo;s <a href="https://golang.org/pkg/text/template/">text/template</a> the template itself
can be more than a simple substitution. It can contain conditional expressions, ranges for data and even
include blocks from other templates.</p>

<h2>Templates</h2>

<p><em>mkpage</em> template engine is the Go <a href="https://golang.org/pkg/text/template/">text/template</a> package.
Other template systems could be implemented but I&rsquo;m keeping the experiment simple at this point.</p>

<h3>Conditional elements</h3>

<p>One nice feature of Go&rsquo;s text/template DSL is that template elements can be condition. This can
be done using the &ldquo;if&rdquo; and &ldquo;with&rdquo; template functions. Here&rsquo;s how to show a title conditionally
using the &ldquo;if&rdquo; function.</p>

<pre><code class="language-go">    {{if .title}}And the title is: {{.title}}{{end}}
</code></pre>

<p>or using &ldquo;with&rdquo;</p>

<pre><code class="language-go">    {{with .title}}{{ . }}{{end}}
</code></pre>

<h3>Template blocks</h3>

<p>Go text/templates support defining blocks and rendering them in conjuction with a main template. This is
also supported by <em>mkpage</em>. For each template encountered on the command line it is added to an array of templates
parsed by the text/template package.  Collectively they are then executed which causes final results
render to stdout by <em>mkpage</em>.</p>

<pre><code class="language-shell">    mkpage &quot;content=text:Hello World&quot; testdata/page.tmpl testdata/header.tmpl testdata/footer.tmpl
</code></pre>

<p>Here is what <em>page.tmpl</em> would look like</p>

<pre><code class="language-go">    {{template &quot;header&quot; . }}

        {{.content}}

    {{template &quot;footer&quot; . }}
</code></pre>

<p>The header and footer are then defined in their own template files (though they also could be combined into one
or even be defined in the main template file itself).</p>

<p><em>header.tmpl</em></p>

<pre><code class="language-go">    {{define &quot;header&quot;}}This is the document header{{end}}
</code></pre>

<p><em>footer.tmpl</em></p>

<pre><code class="language-go">    {{define &quot;footer&quot;}}This is the footer{{end}}
</code></pre>

<p>In this example the output would look like</p>

<pre><code class="language-text">    This is the document header

        Hello World

    This is the footer
</code></pre>

<h2>Content formats and data sources</h2>

<p><em>mkpage</em> support three content formats</p>

<ul>
<li>text/plain (e.g. &ldquo;text:&rdquo; when specifying strings and any file expect those having the extension &ldquo;.md&rdquo; or &ldquo;.json&rdquo;)</li>
<li>text/markdown (e.g. &ldquo;markdown:&rdquo; when specifying strings, file extension &ldquo;.md&rdquo;)</li>
<li>application/json (e.g. &ldquo;json:&rdquo; when specifying strings, file extension &ldquo;.json&rdquo;)</li>
</ul>

<p>It also supports three data sources</p>

<ul>
<li>an explicit string (prefixed with a hint, e.g. &ldquo;text:&ldquo;, &ldquo;markdown:&ldquo;, &ldquo;json:&ldquo;)</li>
<li>a filepath and filename</li>
<li>a URL</li>
</ul>

<p>Content type is evaluate and if necessary transformed before going into the Go text/template.</p>

<h2>A note about Markdown dialect</h2>

<p>In additional to populating a template with values from data sources <em>mkpage</em> also includes the
<a href="https://github.com/russross/blackfriday">blackfriday</a> markdown processor.  The <code>blackfriday.MarkdownCommon()</code>
function is envoked whenever markdown content is suggested. That means for strings that have the
&ldquo;markdown:&rdquo; hint prefix, files ending in &ldquo;.md&rdquo; file extension or URL content with the content type
returned as &ldquo;text/markdown&rdquo;.</p>

<h2>Options</h2>

<ul>
<li>-h, -help - get command line help</li>
<li>-v, -version - show <em>mkpage</em> version number</li>
<li>-l, -license - show <em>mkpage</em> license information</li>
<li>-t, -template - show <em>mkpage</em>&rsquo;s default template</li>
</ul>

<h2>Companion utilities</h2>

<p><em>mkpage</em> comes with some helper utilities that make scripting a deconstructed
content management system from Bash easier.</p>

<h3>mkslides</h3>

<p><em>mkslides</em> generates a set of HTML5 slides from a single Markdown file. It uses
the same template engine as <em>mkpage</em></p>

<h3>reldocpath</h3>

<p><em>reldocpath</em> is intended to simplify the calculation of relative
asset paths (e.g. common css files, images, feeds) when working from
a common project directory.</p>

<h4>Example</h4>

<p>You know the path from the source document to target document from the project root folder.</p>

<ul>
<li>Source is <em>course/week/01/readings.html</em><br /></li>
<li>Target is <em>css/site.css</em>.</li>
</ul>

<p>In Bash this would look like&ndash;</p>

<pre><code class="language-shell">    # We know the paths relative to the project directory
    DOC_PATH=&quot;course/week/01/readings.html&quot;
    CSS_PATH=&quot;css/site.css&quot;
    echo $(reldocpath $DOC_PATH $CSS_PATH)
</code></pre>

<p>the output would look like</p>

<pre><code class="language-shell">    ../../../css/site.css
</code></pre>

<h3>slugify</h3>

<p><em>slugify</em> takes one or more command line args (e.g. a phrase like &ldquo;Hello World&rdquo;) and return
an updated version that is more friendly for filenames and URLS (e.g. &ldquo;Hello-World&rdquo;).</p>

<h4>Example</h4>

<pre><code class="language-shell">    slugify My thoughts on functional programming
</code></pre>

<p>Would yield</p>

<pre><code>    My-thoughts-on-functional-programming
</code></pre>

<h3>ws</h3>

<p><em>ws</em> is a simple static file webserver.  It is suitable for viewing your local copy
of your static website on your machine.  It runs with minimal resources and by default
will serve content out to the URL <a href="http://localhost:8000">http://localhost:8000</a>.  It can also be used to host
a static website and has run well on small Amazon virtual machines as well as Raspberry Pi
computers acting as local private network web servers.</p>

<h3>Example</h3>

<pre><code class="language-shell">    ws Sites/mysite.example.org
</code></pre>

<p>This would start the webserver up listen for browser requests on <em><a href="http://localhost:8000">http://localhost:8000</a></em>.
The content viewable by your web browser would be the files inside the <em>Sites/mysite.example.org</em>
directory.</p>

<pre><code class="language-shell">    ws -url http://mysite.example.org:80 Sites/mysite.example.org
</code></pre>

<p>Assume the machine where you are running <em>ws</em> has the name mysite.example.org then your could
point your web browser at <em><a href="http://mysite.example.org">http://mysite.example.org</a></em> and see the web content you have in
<em>Site/mysite.example.org</em> directory.</p>

</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2015 - 2016 <a href="http://library.caltech.edu/CLS_Copyright.htm">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
